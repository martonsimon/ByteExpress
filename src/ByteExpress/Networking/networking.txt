
//send a single packet without asking for response
//send
let myPacket = new MyPacket();
network.send(myPacket, false);

//receive
network.on(MyPacket, (req, res) => {

});



//send a single packet with response
//send
let myPacket = new MyPacket();
network.send(myPacket).subscribe( (req, res) =>
    req.payload;
).catch(() => {});

//receive
network.on(MyPacket, (req, res) => {
    let data = req.data;
    res.send(200);
    //res.send(new MyPacket());
});



//send a continious stream request with path (event request)
//send
let payload = new MyPacket();
network.eventRequest<Packet>("api/path", payload).subscribe(data => {

}, completed => {

}).catch().finally();

//receive
network.onEvent("api/path", (req, res) => {
    let payload = req.body;
    let event = new MyPacket();
    res.push(event);
    res.push(event);
    res.end();
});




// send a communication channel request (tunnel)
//send
network.tunnel("path").subscribe((tunnel) => 
    //first message
    let response = await tunnel.push(packet);

    //second message
    let response = await tunnel.push(packet);

    //wait for incoming
    let packet = await tunnel.nextInbound();
).catch().finally();

//receive
network.onTunnel("path", (tunnel) => {
    let packet1 = await tunnel.nextInbound();
    packet1.res.end();

    let packet2 = await tunnel.nextInbound();
    packet1.res.end();

    await tunnel.push(packet);
});

Packets:
TransferWrapper:
    flags:
        ack
        require_ack
        chunked_packet
    packet_serial (if chunked)
    chunk_id (if chunked)
    packet_id (if !chunked | (chunked && chunk_id is 0))
    payload_length (if !chunked | (chunked && chunk_id is 0))
    payload

RequestPacket
    flags:
        endpoint_is_string
        require_response
        multiple_response
    endpoint string or packet
    request_id (if require response)
    payload (packet_id, packet_length, raw)
ResponsePacket
    flags:
        close_connection //when sending the last response from event stream
        error_respone
    request_id
    code
    payload
RequestError
    cause

StreamRequest
    endpoint
    tunnel_id
StreamData
    flags:
        sender_initiated_stream
        tunnel_requested_by_sender //since both parties can request a tunnel, the id need to be distinguished
        close_connection
        error_respone
    tunnel_id
    payload (contains data, or error response)


3 types of messages:
    request (optional response)
    stream (bidirectional)
    event stream (omnidirectional)

NetworkHandler:
    () -> outboundsource
    inboundDataSource: Observer(id: any) = null
    outboundDataSource: Observable(id: any) = null -> but rather callback
    list of connections

    maxPacketSize //for outbound

    connectionSendRate //delay between packages (important when sending data to mcus)
    connectionPacketsPerAck //how many packets can be sent without waiting for an ack response
    queueSize //

    inboundData(observer)
    outboundData(): returns observer
    onConnected(id) -> add connection
    onDisconnected(id) -> close pending request and remove connection

    send(packet, id):
        serialize packet
        if longer then calculatePayloadSize()
            chop it up into smaller pieces
            set sequence id
        else just wrap it
        add it to network connection queue -> send()
    
    calculatePayloadSize()
    request(packet, expectResponse = true): Promise
    onRequest(Type of packet, callback);
    stream(endpoint): observable
    eventStream<Packet or default>(endpoint): observable<T>

NetworkConnection
    id: any
    sendRate
    packetsPerAck
    queueSize
    outboundDataSource
    requestHandlers

    lastSentAt: 0
    packetsDeltaAck: 0
    queue of packet base of size queueSize

    inboundBuffer: store an id, packet information, and raw payload

    queuePacket(packet) -> adds it to queue
        if no send rate and doesnt waiting for ack
        dispatch as many as possible

        if send rate and doesnt waiting for ack
        dispatch next if possible and set timeout

    dispatch()
        modify packetsdeltaack
        serialize into bytes
        send outbound

    onInboundPacket()
        if a single packet, then handle it
        if a chunk of a packet, start buffering it


    awaitingAck(): packetsperck == packetsdeltaack
        
RequestHandler


    () -> outbound cb
    request(packet, expectResponse): Promise
        prepare packet
        send
        if no expected response then resolve Promise
        otherwise add it to the queue
    onRequest():

